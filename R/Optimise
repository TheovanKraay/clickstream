#' generates a list of markov chains from a given set of clusters
#'
#' @export
#' @description the purpose of this function is to generate pre-computed markov chain objects from clusters of clickstreams.
#' @param clusters The clusters from which to generate markov chain objects
#' @param order The order for the markov chain

fitMarkovChains =function(clusters, order=1) {
  markovchains <- NULL
  for (i in clusters[[1]]){
    mc <- fitMarkovChain(i, order = order) 
    markovchains <- append(markovchains, mc)
  }
  return(markovchains)
}


#' generates the optimal markov chains from a list of markov chains and corresponding clusters
#'
#' @export
#' @description the purpose of this function is to predict from a pattern using pre-computed markov chains and corresponding clusters. The markov chain corresponding with the cluster that is the best fit to the prediction value is used.
#' @param startPattern The pattern object to be used
#' @param markovchains The pre-computed markov chains generated from a set of clusters
#' @param clusters The corresponding clusters (should be in the corresponding order as the markov chains)
#' @examples 
#' 
#' training <- c("User1,h,c,c,p,c,h,c,p,p,c,p,p,o",
#'               "User2,i,c,i,c,c,c,d",
#'               "User3,h,i,c,i,c,p,c,c,p,c,c,i,d",
#'               "User4,c,c,p,c,d")
#' 
#' test <- c("User1,h,c,c,p,p,h,c,p,p,c,p,p,o",
#'           "User2,i,c,i,c,c,c,d",
#'           "User4,c,c,c,c,d")
#' 
#' csf <- tempfile()
#' writeLines(training, csf)
#' trainingCLS <- readClickstreams(csf, header = TRUE)
#' 
#' csf <- tempfile()
#' writeLines(test, csf)
#' testCLS <- readClickstreams(csf, header = TRUE)
#' 
#' clusters <- clusterClickstreams(trainingCLS, centers = 2)
#' markovchains <- fitMarkovChains(clusters, order = 1)
#' startPattern <- new("Pattern", sequence = c("c")) 
#' mc <- getOptimalMarkovChain(startPattern, markovchains, clusters)
#' predict(mc, startPattern)

getOptimalMarkovChain =function(startPattern, markovchains, clusters) {
  markovchainIndex <- predict(clusters, startPattern)
  optimalPreComputedChain <- markovchains[[markovchainIndex]]
  return(optimalPreComputedChain)
}

#' generates an optimal set of clusters for a clickstream based on certain constraints.
#'
#' @export
#' @description this is an experimental function which allows clustering based on targetting an average figure for next click probabilities derived when fitting each cluster to a markov chain. The user can either 
#' @param cls The clickstream
#' @param maxIterations number of times to iterate (repeat) through the k-means clustering.
#' @param optimalProbMean The target average probability of each next page click prediction in a 1st order markov chain
#' @param range the range above the optimal probability to target. 
#' @param clusterCentresRange the additional cluster centres to evaluate
#' @param divisor the number by which to divide the total number of clicks (determines how many cluster centres to start with)
#' @param takeHighest determines whether to default to the highest mean next click probability, or error if the target is not reached after the given number of k-means iterations 
#' @param order The order for markov chains that will be used to evaluate each cluster
#' 
#' @examples
#' clickstreams <- c("User1,h,c,c,p,c,h,c,p,p,c,p,p,o",
#'                   "User2,i,c,i,c,c,c,d",
#'                   "User3,h,i,c,i,c,p,c,c,p,c,c,i,d",
#'                   "User4,c,c,p,c,d",
#'                   "User5,h,c,c,p,p,c,p,p,p,i,p,o",
#'                   "User7,i,h,c,c,p,p,c,p,c,d",
#'                   "User8,i,h,c,c,p,p,c,p,c,d",
#'                   "User9,i,h,c,c,p,p,c,p,c,d",
#'                   "User10,i,h,c,c,p,p,c,p,c,d",
#'                   "User11,i,h,c,c,p,p,c,p,c,d,z")
#' 
#' csf <- tempfile()
#' writeLines(clickstreams, csf)
#' cls <- readClickstreams(csf, header = TRUE)
#' cls
#' 
#' cluster <- getOptimalClusters(cls, centresMax = 3, order = 1)
#' markovchains <- fitMarkovChains(cluster) 
#' startPattern <- new("Pattern", sequence = c("H")) 
#' predictFromMarkovChains(startPattern,markovchains,cluster)

getOptimalClusters = function(cls, maxIterations=10, optimalProbMean=0.60, range=0.055, divisor=1000, order=1, clusterCentresRange=0, takeHighest=TRUE){
  vectorOfClickstreamLengths <- NULL
  for(i in cls){
    vectorOfClickstreamLengths <- append(vectorOfClickstreamLengths, length(i))
  }
  clicks <- sum(vectorOfClickstreamLengths)
  clicks <- clicks/divisor
  clicks <- floor(clicks)
  centresMin <- clicks
  vec<-unlist(cls)
  dedupe <- vec[which(!duplicated(vec))]
  if (centresMin > length(dedupe)){
    centresMin = length(dedupe)
  }
  centresMax <- centresMin + clusterCentresRange
  clusterOfClusters <- list()
  clusterCentres <- centresMin:centresMax
  iterations <- 1:maxIterations
  vectorOfAllProbsMeans <-NULL
  limit <- optimalProbMean + range
  print(optimalProbMean)
  print(limit)
  for (i in iterations){
    for (c in clusterCentres){
      print(c)
      clusters <- clusterClickstreams(cls, centers = c) 
      markovchains <- fitMarkovChains(clusters, order = order) 
      vectorOfProbs <-NULL
      for (d in dedupe){
        if(d !="Defer"){
          value <- d[[1]]
          startPattern <- new("Pattern", sequence = c(value)) 
          mc <- getOptimalMarkovChain(startPattern,markovchains,clusters)
          prob <- predict(mc, startPattern)
          vectorOfProbs <- append(vectorOfProbs, prob@probability)
        }
      }
      vectorOfAllProbsMeans <- append(vectorOfAllProbsMeans, mean(vectorOfProbs))
      clusterOfClusters <- list.append(clusterOfClusters, clusters)
    }
    print(vectorOfAllProbsMeans)
    indexOfHighestProbs <- which(vectorOfAllProbsMeans>optimalProbMean & vectorOfAllProbsMeans < limit)
    print(indexOfHighestProbs)
    #return the best set of clusters
    if (takeHighest != TRUE){
      if (length(indexOfHighestProbs) > 0){
        break
      }
    }
  }
  if (takeHighest != TRUE){
    if (length(indexOfHighestProbs) > 0){
      return(clusterOfClusters[[indexOfHighestProbs]])
    }
    else{
      stop(("target prediction accuracy was not reached with the given number of iterations"))
    }
  }
  else{
    if (length(indexOfHighestProbs) == 0){
      warning("target prediction accuracy was not reached with the given number of iterations. Taking highest probability mean")
    }
    indexOfHighestProbs <- which(vectorOfAllProbsMeans==max(vectorOfAllProbsMeans))
    return(clusterOfClusters[[indexOfHighestProbs]])
  }
}
