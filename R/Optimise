#' generates a list of markov chains from a given set of clusters
#'
#' @export
#' @description the purpose of this function is to generate pre-computed markov chain objects from clusters of clickstreams.
#' @param clusters The clusters from which to generate markov chain objects
#' @param order The order for the markov chain

fitMarkovChains =function(clusters, order=1) {
  markovchains <- NULL
  for (i in clusters[[1]]){
    mc <- fitMarkovChain(i, order = order) 
    markovchains <- append(markovchains, mc)
  }
  return(markovchains)
}


#' generates the optimal markov chains from a list of markov chains and corresponding clusters
#'
#' @export
#' @description the purpose of this function is to predict from a pattern using pre-computed markov chains and corresponding clusters. The markov chain corresponding with the cluster that is the best fit to the prediction value is used.
#' @param startPattern The pattern object to be used
#' @param markovchains The pre-computed markov chains generated from a set of clusters
#' @param clusters The corresponding clusters (should be in the corresponding order as the markov chains)
#' @examples 
#' 
#' training <- c("User1,h,c,c,p,c,h,c,p,p,c,p,p,o",
#'               "User2,i,c,i,c,c,c,d",
#'               "User3,h,i,c,i,c,p,c,c,p,c,c,i,d",
#'               "User4,c,c,p,c,d")
#' 
#' test <- c("User1,h,c,c,p,p,h,c,p,p,c,p,p,o",
#'           "User2,i,c,i,c,c,c,d",
#'           "User4,c,c,c,c,d")
#' 
#' csf <- tempfile()
#' writeLines(training, csf)
#' trainingCLS <- readClickstreams(csf, header = TRUE)
#' 
#' csf <- tempfile()
#' writeLines(test, csf)
#' testCLS <- readClickstreams(csf, header = TRUE)
#' 
#' clusters <- clusterClickstreams(trainingCLS, centers = 2)
#' markovchains <- fitMarkovChains(clusters, order = 1)
#' startPattern <- new("Pattern", sequence = c("c")) 
#' mc <- getOptimalMarkovChain(startPattern, markovchains, clusters)
#' predict(mc, startPattern)

getOptimalMarkovChain =function(startPattern, markovchains, clusters) {
  markovchainIndex <- predict(clusters, startPattern)
  optimalPreComputedChain <- markovchains[[markovchainIndex]]
  return(optimalPreComputedChain)
}

#' generates an optimal set of clusters for a clickstream based on certain constraints.
#'
#' @export
#' @description this is an experimental function which allows consensus clustering based on targetting an average figure for next click probabilities derived when fitting each cluster to a markov chain. The user can either 
#' @param cls The clickstream
#' @param maxIterations number of times to iterate (repeat) through the k-means clustering.
#' @param optimalProbMean The target average probability of each next page click prediction in a 1st order markov chain
#' @param range the range above the optimal probability to target. 
#' @param clusterCentresRange the additional cluster centres to evaluate
#' @param divisor the number by which to divide the total number of clicks (determines how many cluster centres to start with)
#' @param takeHighest determines whether to default to the highest mean next click probability, or error if the target is not reached after the given number of k-means iterations 
#' @param order The order for markov chains that will be used to evaluate each cluster
#' 
#' @examples
#' clickstreams <- c("User1,h,c,c,p,c,h,c,p,p,c,p,p,o",
#'                   "User2,i,c,i,c,c,c,d",
#'                   "User3,h,i,c,i,c,p,c,c,p,c,c,i,d",
#'                   "User4,c,c,p,c,d",
#'                   "User5,h,c,c,p,p,c,p,p,p,i,p,o",
#'                   "User7,i,h,c,c,p,p,c,p,c,d",
#'                   "User8,i,h,c,c,p,p,c,p,c,d",
#'                   "User9,i,h,c,c,p,p,c,p,c,d",
#'                   "User10,i,h,c,c,p,p,c,p,c,d",
#'                   "User11,i,h,c,c,p,p,c,p,c,d,z")
#' 
#' csf <- tempfile()
#' writeLines(clickstreams, csf)
#' cls <- readClickstreams(csf, header = TRUE)
#' cls
#' 
#' clusters <- getConsensusClusters(cls, centresMax = 3, order = 1)
#' markovchains <- fitMarkovChains(clusters) 
#' startPattern <- new("Pattern", sequence = c("h")) 
#' mc <- getOptimalMarkovChain(startPattern, markovchains, clusters)
#' predict(mc, startPattern)

getConsensusClusters = function(trainingCLS, testCLS, maxIterations=10, optimalProbMean=0.40, range=0.10, centresMin=2, order=1, clusterCentresRange=0, takeHighest=TRUE){
  cls <- trainingCLS
  vec<-unlist(cls)
  dedupe <- vec[which(!duplicated(vec))]
  centresMax <- centresMin + clusterCentresRange
  listOfClusters <- list()
  clusterCentres <- centresMin:centresMax
  iterations <- 1:maxIterations
  vectorOfAllProbsMeans <-NULL
  limit <- optimalProbMean + range
  print(optimalProbMean)
  print(limit)
  for (i in iterations){
    for (c in clusterCentres){
      print(c)
      clusters <- clusterClickstreams(cls, centers = c) 
      markovchains <- fitMarkovChains(clusters, order = order) 
      vectorOfProbs <-NULL
      print("starting next page probability aggregation....")
      for (d in dedupe){
        if(d !="Defer"){
          value <- d[[1]]
          startPattern <- new("Pattern", sequence = c(value)) 
          mc <- getOptimalMarkovChain(startPattern,markovchains,clusters)
          prob <- predict(mc, startPattern)
          vectorOfProbs <- append(vectorOfProbs, prob@probability)
        }
      }
      vectorOfAllProbsMeans <- append(vectorOfAllProbsMeans, mean(vectorOfProbs))
      listOfClusters <- list.append(listOfClusters, clusters)
    }
    print(vectorOfAllProbsMeans)
    candidates <- which(vectorOfAllProbsMeans>optimalProbMean & vectorOfAllProbsMeans < limit)
    cat("candidates are: ",candidates,"\n")
  }
  if (takeHighest != TRUE){
    if (length(candidates) > 0){
      #get the candidate clusters into a vector
      candidateClusters <- list()
      for (i in candidates){
        clusters <- listOfClusters[[i]]
        candidateClusters <- list.append(candidateClusters,clusters)
      }
      print("Evaluating candidate models.....")
      vec_variances <- NULL
      for(c in candidateClusters){
        markovchains <- fitMarkovChains(c) 
        variance <- mcEvaluateAllClusters(markovchains,c,testCLS,trainingCLS,returnChiSquareOnly = TRUE)
        cat("variance is....",variance,"\n")
        vec_variances <- append(vec_variances,variance)
      }
      cat("vec_variances is: ",vec_variances,"\n")
      winner <- which(vec_variances==min(vec_variances))
      cat("winner is: ",winner,"\n")
      return(candidateClusters[[winner]])
    }
    else{
      stop(("target range was not reached with the given number of iterations"))
    }
  }
  else{
    if (length(candidates) == 0){
      warning("target prediction accuracy was not reached with the given number of iterations. Taking highest probability mean")
    }
    candidates <- which(vectorOfAllProbsMeans==max(vectorOfAllProbsMeans))
    return(listOfClusters[[candidates]])
  }
}
